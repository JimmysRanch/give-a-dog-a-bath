<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Give A Dog A Bath by: Scruffy Butts</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(180deg, #a8e6cf, #dcedc1, #ffd3b6);
      overflow: hidden;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 1.2rem;
      z-index: 10;
      color: #333;
    }
    /* Game title displayed at the top centre */
    #gameTitle {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      font-weight: bold;
      z-index: 10;
      color: #333;
      pointer-events: none;
    }
    /* Logo image positioned in the top‑right corner */
    #logo {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 80px;
      height: auto;
      z-index: 10;
    }
    /* Mud puddle obstacle styling: a simple brown ellipse */
    .mud {
      width: 100px;
      height: 30px;
      background: #8B4513;
      border-radius: 50%;
      position: absolute;
      bottom: 10px;
    }
    #gameArea {
      position: relative;
      width: 100vw;
      height: 70vh;
      margin: 50px auto;
      border: 3px solid #333;
      border-radius: 10px;
      overflow: hidden;
      /* Use a repeating farm landscape image as the background. The image
         scrolls horizontally as the dog moves to give the impression of
         travelling through a countryside. Ensure the image spans the full
         height of the game area and repeats along the x-axis. */
      background-image: url('farm_background.png');
      background-repeat: repeat-x;
      background-size: auto 100%;
    }
    /* Dog */
    #dog {
      position: absolute;
      /* Place the dog right on the ground rather than hovering. */
      bottom: 0;
      left: 60px;
      width: 80px;
      height: auto;
      transition: bottom 0.1s;
      user-select: none;
      /* Disable pointer events so the dog doesn’t block clicks on the game area. */
      pointer-events: none;
    }
    /* Obstacles */
    .obstacle {
      position: absolute;
      bottom: 10px;
    }
    /* Override default obstacle styles to remove backgrounds */
    .sprinkler,
    .pool,
    .hose,
    .truck {
      background: none;
      position: absolute;
      bottom: 10px;
      object-fit: contain;
    }
    /* Set sizes for each obstacle image */
    .sprinkler {
      width: 80px;
      height: 80px;
    }
    .pool {
      width: 150px;
      height: 50px;
    }
    .hose {
      width: 120px;
      height: 120px;
    }
    .truck {
      width: 160px;
      height: 90px;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: #fff;
      font-size: 1.5rem;
      display: none;
    }
    #overlay button {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      background: #ff8b94;
      border-radius: 5px;
    }

    /* Instruction overlay */
    #instructionOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: #fff;
      z-index: 20;
    }
    #instructionOverlay h2 {
      margin: 0;
      font-size: 2rem;
    }
    #instructionOverlay p {
      margin: 10px 0;
      font-size: 1.1rem;
      text-align: center;
      line-height: 1.4;
    }
    #instructionOverlay button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 1.2rem;
      cursor: pointer;
      border: none;
      background: #ff8b94;
      border-radius: 5px;
    }

    /* On‑screen controls for mobile devices. These buttons allow the
       player to move the dog left or right on touch devices such as
       iPhones. They are positioned at the bottom centre of the game
       area and styled with semi‑transparent backgrounds so they are
       visible without obscuring the play field. */
    /* Cluster of left/right movement buttons. Positioned on the bottom
       right of the game area. Hidden until the game starts. */
         /* Container for the on‑screen controls. Placed below the game area so
            the buttons no longer overlay the playfield. Hidden until the game
            starts. */
         #controlContainer {
           /* Hide the control container until the game starts. We only set
              display:flex in the startGame() function when we want the
              controls to appear. If we declare display:flex here as
              well as display:none, the latter will be overridden and the
              container will remain visible on page load. */
           display: none;
           width: 100%;
           margin-top: 10px;
           justify-content: space-between;
           padding: 0 10px;
           box-sizing: border-box;
         }
         /* On‑screen movement buttons (cluster on right side within controlContainer) */
         #controls {
           display: flex;
           gap: 30px;
         }
         #controls button {
           width: 60px;
           height: 60px;
           border-radius: 50%;
           border: none;
           background: rgba(255, 255, 255, 0.8);
           font-size: 2rem;
           line-height: 1;
           cursor: pointer;
           user-select: none;
         }
         /* Jump button styling. The button is inside controlContainer on the
            left side. It is hidden until the game starts. */
         #jumpBtn {
           width: 60px;
           height: 60px;
           border: none;
           border-radius: 50%;
           background: rgba(255, 255, 255, 0.8);
           font-size: 2rem;
           line-height: 1;
           cursor: pointer;
           user-select: none;
           display: none; /* Hide until game start */
         }
  </style>
</head>
<body>
  <!-- Game title centred at the top -->
  <div id="gameTitle">Give A Dog A Bath</div>
  <!-- Placeholder for Scruffy Butts logo. Replace logo.png with your own
       logo file once uploaded to the repository. -->
  <!-- Add a cache‑busting query parameter to ensure the latest logo loads -->
  <img id="logo" src="logo.png?v=1" alt="Scruffy Butts Logo">
  <div id="score">Score: 0</div>
  <div id="gameArea">
    <!-- Instruction overlay shown at the start -->
    <div id="instructionOverlay">
      <h2>Give A Dog A Bath</h2>
      <p>
        Use the ← and → arrow keys on a keyboard or the on‑screen left and right buttons at the bottom to move the dog at your own pace.<br>
        Tap anywhere in the game area, press Space/↑, or tap the Jump button on the bottom left to make the dog jump.<br>
        Avoid sprinklers, pools, hoses and fire trucks – those are water!<br>
        Hit mud puddles to grow bigger and jump higher. While muddy, hitting water will shrink you back to normal instead of ending the game. Hitting water when normal ends the game.
      </p>
      <button id="startBtn">Start</button>
    </div>
    <!-- Game over overlay -->
    <div id="overlay">
      <div id="gameOverText"></div>
      <button id="restartBtn">Restart</button>
    </div>
    <!-- Dog image. Use a uniform-sized idle frame for the initial dog image.  This ensures
         that the dog does not appear to grow or shrink when toggling between
         running frames. -->
    <img id="dog" src="dog_run2_uniform.png" alt="Dog">
    <!-- On‑screen controls have been moved outside the game area -->
  </div>
  <!-- Container for the on‑screen controls. This will be placed below the game area
       and holds the jump button on the left and the movement buttons on the right. -->
  <div id="controlContainer">
    <button id="jumpBtn" aria-label="Jump">↑</button>
    <div id="controls">
      <button id="leftBtn" aria-label="Move Left">←</button>
      <button id="rightBtn" aria-label="Move Right">→</button>
    </div>
  </div>
  <script>
    (function() {
      const gameArea = document.getElementById('gameArea');
      const dog = document.getElementById('dog');
      const scoreEl = document.getElementById('score');
      const overlay = document.getElementById('overlay');
      const gameOverText = document.getElementById('gameOverText');
      const restartBtn = document.getElementById('restartBtn');
      const instructionOverlay = document.getElementById('instructionOverlay');
      const startBtn = document.getElementById('startBtn');
      // On‑screen controls for mobile devices. Retrieve the left and right
      // buttons and set up touch and mouse events to control horizontal
      // movement. The handlers update the moveState flags and call
      // updateHorizontalVelocity() to adjust the dog's velocity.
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const controls = document.getElementById('controls');
      const jumpBtn = document.getElementById('jumpBtn');
      // Container that holds both the jump button and movement buttons. This
      // element lives below the game area and is shown/hidden when the
      // game starts or ends.
      const controlContainer = document.getElementById('controlContainer');

      function handleLeftStart() {
        moveState.left = true;
        updateHorizontalVelocity();
      }
      function handleLeftEnd() {
        moveState.left = false;
        updateHorizontalVelocity();
      }
      function handleRightStart() {
        moveState.right = true;
        updateHorizontalVelocity();
      }
      function handleRightEnd() {
        moveState.right = false;
        updateHorizontalVelocity();
      }

      // Handle jump button presses. When the jump button is pressed (either
      // via touch or mouse down) the dog will jump once if not already
      // jumping. The event is prevented to avoid triggering click events.
      function handleJumpPress(e) {
        if (e && e.preventDefault) e.preventDefault();
        if (!isJumping) {
          jump();
        }
      }
      // Attach event listeners for touch and mouse interactions on the
      // on‑screen buttons. Prevent default on touch events to avoid
      // interfering with the game scroll or other gestures. Use
      // mouseleave to stop movement if the pointer leaves the button
      // while still pressed.
      if (leftBtn && rightBtn) {
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleLeftStart(); }, {passive: false});
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleLeftEnd(); }, {passive: false});
        leftBtn.addEventListener('mousedown', handleLeftStart);
        leftBtn.addEventListener('mouseup', handleLeftEnd);
        leftBtn.addEventListener('mouseleave', handleLeftEnd);
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleRightStart(); }, {passive: false});
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleRightEnd(); }, {passive: false});
        rightBtn.addEventListener('mousedown', handleRightStart);
        rightBtn.addEventListener('mouseup', handleRightEnd);
        rightBtn.addEventListener('mouseleave', handleRightEnd);
      }

      // Attach jump button event listeners if present. Use touchstart and
      // mousedown to initiate a jump immediately on press.
      if (jumpBtn) {
        jumpBtn.addEventListener('touchstart', (e) => { handleJumpPress(e); }, {passive: false});
        jumpBtn.addEventListener('mousedown', (e) => { handleJumpPress(e); });
      }

      // Touch controls: tap the left or right half of the game area to
      // move the dog left or right on touch devices. Each touch start
      // will also trigger a jump if the dog is not already jumping, so
      // that a quick tap will both jump and move. Movement stops when
      // the touch ends. We prevent default behaviour on these events to
      // avoid the click event firing after touchend. These listeners are
      // passive false so we can call preventDefault().
      function handleTouchDirection(e) {
        const touch = e.touches && e.touches[0];
        if (!touch) return;
        const rect = gameArea.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        // Determine which side of the game area the touch is in
        if (x < rect.width / 2) {
          moveState.left = true;
          moveState.right = false;
        } else {
          moveState.right = true;
          moveState.left = false;
        }
        updateHorizontalVelocity();
      }

      function handleTouchStart(e) {
        // If the game is not running or the instruction overlay is still visible,
        // ignore touches so that the Start button and other UI elements remain clickable.
        if (!gameRunning || instructionOverlay.style.display !== 'none') {
          return;
        }
        // Prevent default to avoid click events after touchend. Trigger a jump when
        // the player touches the screen if not already jumping. We no longer
        // call handleTouchDirection here, as moving left/right by tapping the
        // screen edges has been removed.
        e.preventDefault();
        if (!isJumping) {
          jump();
        }
      }

      function handleTouchMove(e) {
        // Ignore touchmove events when the game is not running or the instruction overlay
        // is visible. This prevents the movement handler from firing while the player
        // is attempting to press the Start button or other UI elements.
        if (!gameRunning || instructionOverlay.style.display !== 'none') {
          return;
        }
        // Prevent default to avoid unintended scrolling or clicks. Do not
        // interpret touchmove as horizontal movement any more.
        e.preventDefault();
      }

      function handleTouchEnd(e) {
        // Ignore touchend events when the game is not running or the instruction overlay
        // is visible. This ensures that releasing a touch over the Start button does not
        // inadvertently reset movement state or prevent the button from being clicked.
        if (!gameRunning || instructionOverlay.style.display !== 'none') {
          return;
        }
        // Prevent default to avoid generating a mouse event after touchend. We no
        // longer update movement state here because screen touches do not
        // control horizontal movement.
        e.preventDefault();
      }

      gameArea.addEventListener('touchstart', handleTouchStart, {passive: false});
      gameArea.addEventListener('touchmove', handleTouchMove, {passive: false});
      gameArea.addEventListener('touchend', handleTouchEnd, {passive: false});
      // Sounds
      // Use jump.wav for the jump sound. This is a short pleasant tone
      // played once per jump. You can replace this file with any other
      // sound by uploading a new file to the repository and changing
      // the filename here. The collision sound remains the beep for now.
      const jumpSound = new Audio('jump.wav');
      const collisionSound = new Audio('beep-01a.mp3');
      let obstacles = [];
      // Muddy state: when the dog hits a mud puddle it becomes muddy, grows
      // larger and can jump higher. While muddy, hitting water will shrink
      // the dog back to normal instead of ending the game. These variables
      // track the muddy status and the current jump height.
      let isMuddy = false;
      const normalJumpHeight = 150;
      const mudJumpHeight = 300;
      let currentJumpHeight = normalJumpHeight;
      // Horizontal movement: dog's velocity (pixels per frame) and world offset.
      let dogVelocityX = 0;
      let worldOffset = 0;
      // Spawn obstacles based on distance travelled: distance since last spawn,
      // current spawn distance threshold, minimum spawn distance, and decrease step.
      let distanceSinceLastSpawn = 0;
      let spawnDistance = 500;
      const minSpawnDistance = 200;
      const spawnDecreaseStep = 10;
      // Variables lastSpawnTime, spawnInterval and speed are removed since obstacles
      // are now spawned based on distance travelled rather than elapsed time.
      let score = 0;
      let gameRunning = false;
      let isJumping = false;
      let lastTime = 0;
      // Define the ground level for the dog (in pixels). Using a constant
      // ground value prevents the dog from gradually floating upwards if
      // multiple jumps are triggered in quick succession. The dog will
      // always start and end its jump at this baseline.
      // Define the ground level for the dog (in pixels). Set this to zero
      // so the dog stands directly on the bottom edge of the game area.
      const ground = 0;

      // Minimum vertical clearance (in pixels) needed for the dog to safely clear
      // an obstacle. If the dog's bottom position is below this value, then
      // collision checks will be performed. Otherwise, collisions are ignored
      // during the jump. This helps prevent premature collisions when the
      // dog is still a fair distance above an obstacle. You may adjust
      // this value to fine‑tune how high the dog must jump to clear
      // different obstacles. A value around 80px works well with the
      // current obstacle heights (50–120px).
      const jumpClearance = 80;

      // Animation state. When the dog moves horizontally we alternate
      // between the idle and running images to give the impression of
      // walking/running. runAnimationInterval holds the interval ID when
      // active. facingLeft tracks the direction the dog is facing. The
      // idleSrc and runSrc variables define the filenames for the idle and
      // running frames.
      let runAnimationInterval = null;
      let facingLeft = false;
      /*
       * Running animation frames. To keep the dog consistent between idle and
       * running states we use two frames derived from the same art style.
       * idleSrc points to the first frame, while runFrames contains both
       * frames used when the dog is moving. runFrameIndex tracks the current
       * frame.
       */
      // Use uniform-sized frames for the idle and running images to prevent
      // the dog from appearing to grow or shrink between frames. The
      // images dog_run1_uniform.png and dog_run2_uniform.png are padded to
      // the same dimensions.
      const idleSrc = 'dog_run2_uniform.png';
      const runFrames = ['dog_run2_uniform.png', 'dog_run1_uniform.png'];
      let runFrameIndex = 0;

      // Movement state for left and right arrow keys. We track whether
      // each arrow key is currently pressed so we can determine the
      // dog's horizontal velocity. This allows for smooth transitions
      // when multiple keys are pressed or released.
      const moveState = { left: false, right: false };
      // The horizontal movement speed (in pixels per frame). Feel free
      // to tweak this value to adjust how quickly the dog moves across
      // the screen and the world scrolls.
      const horizontalSpeed = 8;

      // Helper to update the dog's horizontal velocity based on which
      // arrow keys are currently pressed. Right arrow sets a positive
      // velocity, left arrow sets a negative velocity, and if neither
      // arrow (or both) are pressed, the velocity is zero.
      function updateHorizontalVelocity() {
        if (moveState.right && !moveState.left) {
          dogVelocityX = horizontalSpeed;
        } else if (moveState.left && !moveState.right) {
          dogVelocityX = -horizontalSpeed;
        } else {
          dogVelocityX = 0;
        }
        // Update facing direction based on velocity. When moving right the
        // dog faces right; when moving left it faces left. If velocity is
        // zero we leave the facing direction unchanged so the dog keeps
        // looking the last direction it moved.
        if (dogVelocityX > 0) {
          facingLeft = false;
        } else if (dogVelocityX < 0) {
          facingLeft = true;
        }
        updateDogTransform();
      }

      function startGame() {
        // reset game
        obstacles.forEach(o => o.remove());
        obstacles = [];
        // Reset world and horizontal movement state
        worldOffset = 0;
        dogVelocityX = 0;
        distanceSinceLastSpawn = 0;
        spawnDistance = 500;
        score = 0;
        scoreEl.textContent = 'Score: 0';
        gameRunning = true;
        overlay.style.display = 'none';
        // Reset dog position to the ground level
        dog.style.bottom = ground + 'px';
        // Reset muddy status, orientation and animation state
        isMuddy = false;
        facingLeft = false;
        currentJumpHeight = normalJumpHeight;
        // Set the dog's default image and stop any running animation
        dog.src = idleSrc;
        stopRunAnimation();
        // Apply the correct transform (scale and orientation)
        updateDogTransform();
        // Show the on-screen control container and its buttons on game start. This
        // container holds the jump button on the left and the movement buttons on
        // the right.
        if (controlContainer) controlContainer.style.display = 'flex';
        if (controls) controls.style.display = 'flex';
        if (jumpBtn) jumpBtn.style.display = 'block';
        // Start loop
        lastTime = performance.now();
        requestAnimationFrame(update);
      }

      function createObstacle() {
        // Include mud puddles as an additional obstacle type. Water obstacles
        // include sprinkler, pool, hose and truck. Mud obstacles use a
        // simple div with brown colour defined in CSS.
        const types = ['sprinkler', 'pool', 'hose', 'truck', 'mud'];
        const type = types[Math.floor(Math.random() * types.length)];
        let ob;
        if (type === 'mud') {
          // Create a simple div for mud puddle
          ob = document.createElement('div');
          ob.classList.add('obstacle', 'mud');
        } else {
          ob = document.createElement('img');
          if (type === 'sprinkler') {
            ob.src = 'sprinkler.png';
          } else if (type === 'pool') {
            ob.src = 'puddle.png';
          } else if (type === 'hose') {
            ob.src = 'hose.png';
          } else if (type === 'truck') {
            ob.src = 'firetruck.png';
          }
          ob.classList.add(type);
        }
        ob.classList.add('obstacle');
        // Assign a world coordinate ahead of the current view. Add a random gap so obstacles are not evenly spaced.
        const gap = Math.random() * 200 + 200;
        // Place the obstacle just beyond the right edge of the visible area.
        ob.worldX = worldOffset + gameArea.offsetWidth + gap;
        ob.style.left = (ob.worldX - worldOffset) + 'px';
        gameArea.appendChild(ob);
        obstacles.push(ob);
      }

      function update(time) {
        if (!gameRunning) return;
        const delta = time - lastTime;
        lastTime = time;
        // Update world offset based on dog's horizontal velocity. Use delta to make movement frame rate independent.
        worldOffset += dogVelocityX * (delta / 16);
        if (worldOffset < 0) worldOffset = 0;
        // Update the background position so the country stripes scroll as the
        // dog moves horizontally. A negative worldOffset moves the background
        // to the left when the dog moves right and vice versa.
        gameArea.style.backgroundPositionX = (-worldOffset) + 'px';

        // Start or stop the running animation based on horizontal movement.
        if (dogVelocityX !== 0 && !runAnimationInterval) {
          startRunAnimation();
        } else if (dogVelocityX === 0 && runAnimationInterval) {
          stopRunAnimation();
        }
        // Accumulate distance travelled to determine when to spawn the next obstacle.
        if (dogVelocityX > 0) {
          distanceSinceLastSpawn += dogVelocityX * (delta / 16);
        }
        // Update obstacles positions relative to worldOffset, remove off-screen and check collisions.
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const ob = obstacles[i];
          // Calculate new screen left based on world coordinate and worldOffset
          const screenLeft = ob.worldX - worldOffset;
          ob.style.left = screenLeft + 'px';
          // Remove if off screen to the left
          if (screenLeft + ob.offsetWidth < 0) {
            ob.remove();
            obstacles.splice(i, 1);
            continue;
          }
          // Collision detection: Only perform a collision check when the dog
          // is on or near the ground (i.e., its bottom position is below
          // the jumpClearance threshold). This prevents premature
          // collisions while the dog is mid‑air. When the dog jumps high
          // enough (bottom > jumpClearance), collisions are ignored.
          const dogBottomVal = parseFloat(dog.style.bottom);
          if (dogBottomVal < jumpClearance) {
            if (isColliding(dog, ob)) {
              // Determine how to handle the collision based on obstacle type.
              if (ob.classList.contains('mud')) {
                // Mud puddle: become muddy and remove the puddle
                getMuddy();
                ob.remove();
                obstacles.splice(i, 1);
                continue;
              }
              // Check for water obstacles: sprinkler, pool, hose or truck
              if (ob.classList.contains('sprinkler') ||
                  ob.classList.contains('pool') ||
                  ob.classList.contains('hose') ||
                  ob.classList.contains('truck')) {
                // Hitting water when muddy shrinks back to normal; otherwise game over
                if (isMuddy) {
                  hitWater();
                  ob.remove();
                  obstacles.splice(i, 1);
                  continue;
                } else {
                  endGame();
                  return;
                }
              }
              // Any other obstacle type triggers game over
              endGame();
              return;
            }
          }
        }
        // Spawn a new obstacle if enough distance has been travelled
        if (distanceSinceLastSpawn > spawnDistance) {
          createObstacle();
          distanceSinceLastSpawn = 0;
          // Gradually decrease the spawn distance down to a minimum to ramp difficulty.
          if (spawnDistance > minSpawnDistance) {
            spawnDistance -= spawnDecreaseStep;
          }
        }
        // Increase score based on distance travelled (both directions contribute)
        score += Math.abs(dogVelocityX) * (delta / 16) * 0.1;
        scoreEl.textContent = 'Score: ' + Math.floor(score);
        requestAnimationFrame(update);
      }

      function getRect(el) {
        return el.getBoundingClientRect();
      }

      function isColliding(a, b) {
        const rect1 = getRect(a);
        const rect2 = getRect(b);
        // Use the dog's horizontal centre to determine overlap rather than its
        // entire bounding box. This avoids premature collisions when the
        // dog's tail or front overlaps the obstacle but its body hasn't yet
        // reached the water. Only trigger a collision when the dog's centre
        // lies within the obstacle's horizontal extent and its bottom is
        // below the obstacle's top.
        const centerX = rect1.left + rect1.width / 2;
        const horizontallyAligned = centerX > rect2.left && centerX < rect2.right;
        const verticallyAligned = rect1.bottom > rect2.top;
        return horizontallyAligned && verticallyAligned;
      }

      /**
       * Update the dog's CSS transform to reflect its current scale and
       * facing direction. The dog grows larger when muddy and flips
       * horizontally when facing left. We compose scale and flip into a
       * single transform string. This helper should be called whenever
       * isMuddy or facingLeft changes.
       */
      function updateDogTransform() {
        const scaleFactor = isMuddy ? 2 : 1;
        // If facing left, flip horizontally by applying scaleX(-1). We
        // append the scaling factor afterwards so that the dog can both
        // grow and flip correctly.  Without flipping the dog appears to
        // always face right.
        if (facingLeft) {
          dog.style.transform = `scaleX(-1) scale(${scaleFactor})`;
        } else {
          dog.style.transform = `scale(${scaleFactor})`;
        }
      }

      /**
       * Start the run animation. When active, this interval toggles the
       * dog's image between the idle and running sprites every 200ms to
       * simulate walking or running. If the animation is already running
       * the call has no effect.
       */
      function startRunAnimation() {
        // If an animation is already running, do nothing. Otherwise start
        // cycling through the runFrames array. Each tick advances the
        // runFrameIndex and updates the dog's src accordingly. The idle
        // frame serves as the first element in the array so there is no
        // abrupt change when the dog starts moving.
        if (runAnimationInterval) return;
        runAnimationInterval = setInterval(() => {
          runFrameIndex = (runFrameIndex + 1) % runFrames.length;
          dog.src = runFrames[runFrameIndex];
        }, 200);
      }

      /**
       * Stop the run animation. Clears the interval and resets the dog's
       * image to the idle sprite. If no animation is active, this is a
       * no‑op.
       */
      function stopRunAnimation() {
        // Stop the running animation and reset the dog's image back to
        // the idle frame. This clears the interval and resets the
        // runFrameIndex so the next time the animation starts it will
        // begin from the idle frame.
        if (!runAnimationInterval) return;
        clearInterval(runAnimationInterval);
        runAnimationInterval = null;
        runFrameIndex = 0;
        dog.src = idleSrc;
      }

      // When the dog collides with a mud puddle it becomes muddy. Increase
      // the dog's scale and jump height. If the dog is already muddy this
      // does nothing. The mud puddle obstacle will be removed by the caller.
      function getMuddy() {
        if (!isMuddy) {
          isMuddy = true;
          currentJumpHeight = mudJumpHeight;
          // Update the transform so the dog grows while preserving facing
          updateDogTransform();
        }
      }

      // When the dog collides with a water obstacle. If it is muddy it
      // shrinks back to normal size and can continue. Otherwise the game
      // ends. The caller is responsible for removing the obstacle on
      // collision.
      function hitWater() {
        if (isMuddy) {
          isMuddy = false;
          currentJumpHeight = normalJumpHeight;
          // Update transform so the dog shrinks back to normal size but keeps
          // its facing direction
          updateDogTransform();
        } else {
          endGame();
        }
      }

      function jump() {
        if (isJumping) return;
        isJumping = true;
        // play jump sound exactly once per jump. Reset the audio to
        // the beginning and ensure it is not already playing before
        // starting playback. This prevents multiple barks from
        // overlapping if the button is pressed repeatedly.
        jumpSound.pause();
        jumpSound.currentTime = 0;
        jumpSound.play();
        const start = Date.now();
        // Always start jumping from the ground level to avoid drift. Using a
        // constant starting bottom ensures repeated jumps don’t cause the dog
        // to gradually float upwards.
        const startBottom = ground;
        // Use the current jump height which may be increased when muddy.
        const jumpHeight = currentJumpHeight;
        const duration = 700;
        function animate() {
          const elapsed = Date.now() - start;
          if (elapsed < duration / 2) {
            const progress = elapsed / (duration / 2);
            dog.style.bottom = startBottom + jumpHeight * progress + 'px';
          } else if (elapsed < duration) {
            const progress = (elapsed - duration / 2) / (duration / 2);
            dog.style.bottom = startBottom + jumpHeight * (1 - progress) + 'px';
              } else {
                // Ensure the dog returns to the ground level at the end of the jump
                dog.style.bottom = ground + 'px';
                isJumping = false;
                return;
              }
              requestAnimationFrame(animate);
            }
            animate();
          }

      function endGame() {
        gameRunning = false;
        // play collision sound
        collisionSound.currentTime = 0;
        collisionSound.play();
        overlay.style.display = 'flex';
        gameOverText.textContent = 'Game Over! Your score: ' + Math.floor(score);
        // Hide the control container and its buttons when the game ends so accidental taps don’t trigger movement
        if (controlContainer) controlContainer.style.display = 'none';
        if (controls) controls.style.display = 'none';
        if (jumpBtn) jumpBtn.style.display = 'none';
      }

      // control events
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          jump();
        } else if (e.code === 'ArrowLeft') {
          moveState.left = true;
          updateHorizontalVelocity();
        } else if (e.code === 'ArrowRight') {
          moveState.right = true;
          updateHorizontalVelocity();
        }
      });
      document.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowLeft') {
          moveState.left = false;
          updateHorizontalVelocity();
        } else if (e.code === 'ArrowRight') {
          moveState.right = false;
          updateHorizontalVelocity();
        }
      });
      // Allow clicking to trigger a jump only when the game is running and the
      // instruction overlay has been dismissed. Without this guard, clicks on
      // the instruction overlay could be intercepted by the game area,
      // preventing the Start button from working on touch devices. When the
      // game is not running or the instruction overlay is visible, clicks
      // should be handled by the UI elements (e.g., Start button) instead of
      // triggering a jump.
      gameArea.addEventListener('click', (e) => {
        if (!gameRunning || instructionOverlay.style.display !== 'none') {
          return;
        }
        jump();
      });

      // Do not attach a separate touchstart listener here because handleTouchStart
      // manages touch-based jumping and movement. Adding another listener would
      // cause duplicate jumps and interfere with the Start button on mobile.

      restartBtn.addEventListener('click', () => {
        overlay.style.display = 'none';
        startGame();
      });

      // Start button for initial instructions
      startBtn.addEventListener('click', () => {
        instructionOverlay.style.display = 'none';
        startGame();
      });

      // Do not auto-start; waiting for user to press Start
    })();
  </script>
</body>
</html>
